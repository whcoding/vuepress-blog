---
title: 简单工厂模式
date: 2020-09-27 14:31:55
permalink: /pages/0278fa/
categories:
  - 设计模式
tags:
  - 设计模式
author: 
  name: whcoding
  link: https://github.com/whcoding
---

### 简单工厂模式

- 创建型模式
- 作用: 实现了创建者和调用者分离

### 举个栗子

假设:用户需要买车,每一个车就是一个类, 每一个类都需要new一次, 周一买特斯拉 周二买奥迪 周三买宝马 这样每次都会更改大量的代码.


<!-- more -->


#### 常规流程图:

![54392-7exbf5aattw.png](https://images.whcoding.com/54392-7exbf5aattw.png)

#### 常规的代码:
```
// $car = new Tesla();
// $car = new Audi();
$car = new Benz();

echo $car->name();
```

#### 简单工厂模式流程图:

![15604-gnmgunoifja.png](https://images.whcoding.com/15604-gnmgunoifja.png)

#### 简单工厂模式代码:

工厂文件代码:
```
class Factory
{
    public static function GetLogic($carName)
    {
        $instance = null;
        if ($carName == '奥迪') {
           $instance = new Audi();
        } elseif ($carName == '宝马') {
            $instance = new Benz();
        } elseif ($carName == '特斯拉') {
            $instance = new Tesla();
        }
        return $instance;
    }
}
```

用户文件代码:
````
$myCar = Factory::GetLogic('宝马');
echo $myCar->name();
````

### 总结:

> 优点

- 一个调用者想创建一个对象, 只要知道其名称就可以了.
- 扩展性高,如果想增加一个产品,只要扩展一个工厂类就可以.
- 屏蔽了类的具体实现, 调用者只关心产品的接口.

> 缺点

-  每次增加一个产品时, 都需要修改一个具体类和对象实现工厂, 使得系统中类的个数成倍增加, 在一定程度上增加了系统的复杂度, 同时也增加了系统具体类的依赖
-  同时也违背了设计模式的开闭原则, 因为每次增加一辆车或产品的类都需要去修改工厂方法, 正因为这个原则所以就有了 方法工厂模式

### 完整示例代码:

[Github](https://github.com/whcoding/design-patterns-study/tree/master/src/Factory/Simple)